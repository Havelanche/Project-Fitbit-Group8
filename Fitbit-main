import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import statsmodels.formula.api as smf
import sqlite3 as sql


def load_data(filename):
    df = pd.read_csv(filename)
    df['ActivityDate'] = pd.to_datetime(df['ActivityDate'])
    return df

def get_unique_users(df, column_name):
    unique_users = df.groupby('Id')[column_name].sum().reset_index()
    unique_users.insert(0, 'Index', range(1, len(unique_users) + 1))
    unique_users.columns = ['#Users', 'User ID', column_name]
    print(unique_users)
    return unique_users

def plot_distance_distribution(unique_users):
    plt.figure(figsize=(12, 6))
    counts, bins, patches = plt.hist(unique_users['TotalDistance'], bins=10, color='orange', edgecolor='black')
    plt.xticks(bins.round(1))
    plt.xlabel('Total Distance')
    plt.ylabel('Number of Users')
    plt.title('Distribution of Total Distances Covered')
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.show()


def calories_burned_per_day(df, user_id, start_date=None, end_date=None):
    user_data = df[df['Id'] == user_id]
    if start_date and end_date:
        user_data = user_data[(user_data['ActivityDate'] >= start_date) & (user_data['ActivityDate'] <= end_date)]
    
    plt.figure(figsize=(12,6))
    plt.plot(user_data['ActivityDate'], user_data['Calories'], marker='o', linestyle='-')
    plt.xlabel('Day')
    plt.ylabel('Total calories burned')
    plt.title(f'Total calories burned by User {user_id}')
    plt.xticks(rotation=45) 
    plt.grid()
    plt.show()

def plot_workout(df):
    df['DayOfWeek'] = df['ActivityDate'].dt.day_name()
    plt.figure(figsize=(12, 6))
    sns.countplot(x='DayOfWeek', data=df, order=['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'], palette='pastel')
    plt.xlabel('Day of the week')
    plt.ylabel('Workout Count')
    plt.title('Weekly Workout Frequency')
    plt.xticks(rotation=45) 
    plt.show()

def plot_LRM(df, user_id):
    user = df[df['Id'] == user_id]
    plt.figure(figsize=(12,6))
    sns.regplot(x='TotalSteps', y='Calories', data=user, scatter_kws={'alpha':0.5}, line_kws={'color':'red'})
    plt.xlabel('Total Steps')
    plt.ylabel('Calories Burned')
    plt.title(f'Calories vs. Steps for User {user_id}')
    plt.show()

def classify_user(df):
    user_counts = df.groupby('Id').size()
    categories = pd.cut(user_counts, bins=[0, 10, 15, float('inf')], labels=['Light', 'Moderate', 'Heavy'])
    return pd.DataFrame({'Class': categories})

def SQL_acquisition(connection, query):
    cursor = connection.cursor()
    cursor.execute(query)
    rows = cursor.fetchall()
    df = pd.DataFrame(rows, columns=[x[0] for x in cursor.description])
    return df
#task1
def verify_total_steps(df, connection):
    df_database = SQL_acquisition(connection, f"SELECT Id, sum(StepTotal) AS total_steps FROM hourly_steps GROUP BY Id")
    df_csv = df.groupby('Id')['TotalSteps'].sum().reset_index()

    identical = df_database['total_steps'].equals(df_csv['TotalSteps'])
    print("If the total steps in csv file is indentical as in database?:", identical)
#task2
def compute_sleep_duration(connection):
    query = """
        SELECT logId, Id, COUNT(*) AS SleepDuration
        FROM minute_sleep
        GROUP BY logId, Id
        ORDER BY Id, logId
    """
    df_sleep = pd.read_sql_query(query, connection)

    df_sleep["logId"] = df_sleep["logId"].astype(int).astype(str)
    df_sleep["Id"] = df_sleep["Id"].astype(int).astype(str)
    # Display sleep durations
    print("Computed Sleep Duration for Each Sleep Session:")
    print(df_sleep.head(10))  # Show first 10 results

    return df_sleep
#task3
def analyze_sleep_vs_activity(connection):
    """Analyze the relationship between sleep duration and total active minutes."""

    # Query: Compute daily sleep duration in minutes
    query_sleep = """
        SELECT Id, date AS ActivityDate, SUM(value) AS SleepDuration
        FROM minute_sleep
        WHERE value > 0
        GROUP BY Id, ActivityDate
    """
    df_sleep = pd.read_sql_query(query_sleep, connection)

    # Convert sleep duration to hours for better interpretation
    df_sleep["SleepDuration"] = df_sleep["SleepDuration"] / 60  

    # Query: Compute total active minutes per day
    query_activity = """
        SELECT Id, ActivityDate, 
               (VeryActiveMinutes + FairlyActiveMinutes + LightlyActiveMinutes) AS TotalActiveMinutes
        FROM daily_activity
    """
    df_activity = pd.read_sql_query(query_activity, connection)

    # Convert Id and ActivityDate to string for safe merging
    df_sleep["Id"] = df_sleep["Id"].astype(str)
    df_activity["Id"] = df_activity["Id"].astype(str)
    df_sleep["ActivityDate"] = pd.to_datetime(df_sleep["ActivityDate"]).dt.date.astype(str)
    df_activity["ActivityDate"] = pd.to_datetime(df_activity["ActivityDate"]).dt.date.astype(str)

    # Merge datasets on Id and ActivityDate
    df_merged = df_activity.merge(df_sleep, on=["Id", "ActivityDate"], how="inner")

    # Perform regression analysis: SleepDuration ~ TotalActiveMinutes
    model = smf.ols("SleepDuration ~ TotalActiveMinutes", data=df_merged).fit()
    print(model.summary())

    # Plot regression results
    plt.figure(figsize=(8, 5))
    sns.regplot(x=df_merged["TotalActiveMinutes"], y=df_merged["SleepDuration"], 
                scatter_kws={'alpha':0.5}, line_kws={'color':'red'})
    plt.xlabel("Total Active Minutes")
    plt.ylabel("Sleep Duration (hours)")
    plt.title("Regression: Sleep Duration vs. Active Minutes")
    plt.show()

    return df_merged, model

# task4
def analyze_sleep_vs_sedentary(connection):
    try:
      

        # Query: Compute daily sleep duration in minutes
        query_sleep = """
            SELECT Id, date AS ActivityDate, SUM(value) AS SleepDuration
            FROM minute_sleep
            WHERE value > 0
            GROUP BY Id, ActivityDate
        """
        df_sleep = pd.read_sql_query(query_sleep, connection)

        # Convert sleep duration to hours
        df_sleep["SleepDuration"] = df_sleep["SleepDuration"] / 60  

        # Query: Compute daily sedentary minutes
        query_sedentary = """
            SELECT Id, ActivityDate, SedentaryMinutes
            FROM daily_activity
        """
        df_sedentary = pd.read_sql_query(query_sedentary, connection)

        # Convert Id and ActivityDate to string for safe merging
        df_sleep["Id"] = df_sleep["Id"].astype(str)
        df_sedentary["Id"] = df_sedentary["Id"].astype(str)
        df_sleep["ActivityDate"] = pd.to_datetime(df_sleep["ActivityDate"]).dt.date.astype(str)
        df_sedentary["ActivityDate"] = pd.to_datetime(df_sedentary["ActivityDate"]).dt.date.astype(str)

        # Merge datasets on Id and ActivityDate
        df_merged = df_sedentary.merge(df_sleep, on=["Id", "ActivityDate"], how="inner")

        # Check if merge resulted in an empty dataset
        if df_merged.empty:
            print(" Error: Merged dataframe is empty! Check date format in `minute_sleep` and `daily_activity`.")
            return None

        # Perform regression analysis: SleepDuration ~ SedentaryMinutes
        model = smf.ols("SleepDuration ~ SedentaryMinutes", data=df_merged).fit()

        # Display regression summary
        print(model.summary())

        # Plot regression results
        plt.figure(figsize=(8, 5))
        sns.regplot(x=df_merged["SedentaryMinutes"], y=df_merged["SleepDuration"], 
                    scatter_kws={'alpha':0.5}, line_kws={'color':'red'})
        plt.xlabel("Sedentary Minutes")
        plt.ylabel("Sleep Duration (hours)")
        plt.title("Regression: Sleep Duration vs. Sedentary Minutes")
        plt.show()

        # Residual analysis to check normality
        residuals = model.resid

        # Histogram of residuals
        plt.figure(figsize=(8, 5))
        sns.histplot(residuals, kde=True, bins=30)
        plt.xlabel("Residuals")
        plt.ylabel("Frequency")
        plt.title("Residual Distribution (Normality Check)")
        plt.show()

        # Q-Q plot to check normality visually
        sm.qqplot(residuals, line="45", fit=True)
        plt.title("Q-Q Plot of Residuals (Normality Check)")
        plt.show()

        # Perform Shapiro-Wilk test for normality
        shapiro_test_stat, shapiro_p_value = shapiro(residuals.sample(5000, random_state=42))  # Take a sample to avoid large data issue
        print(f"\nShapiro-Wilk Test for Normality:")
        print(f"Test Statistic = {shapiro_test_stat:.4f}, p-value = {shapiro_p_value:.6f}")

        if shapiro_p_value < 0.05:
            print(" Residuals are NOT normally distributed (p-value < 0.05). Consider transformations or a different model.")
        else:
            print(" Residuals appear normally distributed (p-value > 0.05).")

        return model

    except Exception as e:
        print(f"⚠️ An error occurred: {e}")
        return None
#task 5
def plot_activity_by_time_blocks_from_db(connection):
 
    # Query the hourly steps, calories, and minute sleep data
    hourly_steps_query = "SELECT * FROM hourly_steps;"
    hourly_calories_query = "SELECT * FROM hourly_calories;"
    minute_sleep_query = "SELECT * FROM minute_sleep;"
    
    # Load the data into DataFrames
    hourly_steps_df = pd.read_sql(hourly_steps_query, connection)
    hourly_calories_df = pd.read_sql(hourly_calories_query, connection)
    minute_sleep_df = pd.read_sql(minute_sleep_query, connection)
        
    # Convert ActivityHour and date to datetime format for easier processing
    hourly_steps_df['ActivityHour'] = pd.to_datetime(hourly_steps_df['ActivityHour'])
    hourly_calories_df['ActivityHour'] = pd.to_datetime(hourly_calories_df['ActivityHour'])
    minute_sleep_df['date'] = pd.to_datetime(minute_sleep_df['date'])

    # Extract hour from the 'ActivityHour' for hourly data and from 'date' for minute sleep data
    hourly_steps_df['hour'] = hourly_steps_df['ActivityHour'].dt.hour
    hourly_calories_df['hour'] = hourly_calories_df['ActivityHour'].dt.hour
    minute_sleep_df['hour'] = minute_sleep_df['date'].dt.hour

    # Define the 4-hour time blocks
    time_blocks = [(0, 4), (4, 8), (8, 12), (12, 16), (16, 20), (20, 24)]

    # Initialize lists to store the average steps, calories, and sleep per block
    avg_steps = []
    avg_calories = []
    avg_sleep = []

    # Calculate average steps per block
    for start, end in time_blocks:
        block_steps = hourly_steps_df[(hourly_steps_df['hour'] >= start) & (hourly_steps_df['hour'] < end)]
        avg_steps.append(block_steps['StepTotal'].mean())

    # Calculate average calories per block
    for start, end in time_blocks:
        block_calories = hourly_calories_df[(hourly_calories_df['hour'] >= start) & (hourly_calories_df['hour'] < end)]
        avg_calories.append(block_calories['Calories'].mean())

    # Calculate average sleep minutes per block
    for start, end in time_blocks:
        block_sleep = minute_sleep_df[(minute_sleep_df['hour'] >= start) & (minute_sleep_df['hour'] < end)]
        avg_sleep.append(block_sleep['value'].sum() / 60)  # Converting to minutes by dividing by 60

    # Plotting the results
    labels = [f"{start}-{end}" for start, end in time_blocks]
    x = np.arange(len(labels))

    fig, ax = plt.subplots(figsize=(10, 6))

    bar_width = 0.2
    ax.bar(x - bar_width, avg_steps, bar_width, label='Steps', color='b')
    ax.bar(x, avg_calories, bar_width, label='Calories', color='g')
    ax.bar(x + bar_width, avg_sleep, bar_width, label='Sleep (mins)', color='r')

    # Adding labels and title
    ax.set_xlabel('Time Block')
    ax.set_ylabel('Average')
    ax.set_title('Average Steps, Calories, and Sleep per 4-Hour Block')
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.legend()

    # Show the plot
    plt.tight_layout()
    plt.show()   

#task 6    
def plot_heart_rate_and_intensity_by_id(connection, user_id):
    
    # Query the heart rate and hourly intensity data for the specific user
    heart_rate_query = f"SELECT * FROM heart_rate WHERE Id = {user_id};"
    hourly_intensity_query = f"SELECT * FROM hourly_intensity WHERE Id = {user_id};"
    
    # Load the data into DataFrames
    heart_rate_df = pd.read_sql(heart_rate_query, connection)
    hourly_intensity_df = pd.read_sql(hourly_intensity_query, connection)
    
    # Convert the 'Time' column in heart rate data to datetime
    heart_rate_df['Time'] = pd.to_datetime(heart_rate_df['Time'])
    
    # Convert 'ActivityHour' column in intensity data to datetime
    hourly_intensity_df['ActivityHour'] = pd.to_datetime(hourly_intensity_df['ActivityHour'])
    
    # Plotting the heart rate and total intensity on the same figure
    fig, ax1 = plt.subplots(figsize=(12, 6))
    
    # Plot the heart rate data (in blue)
    ax1.set_xlabel('Time')
    ax1.set_ylabel('Heart Rate (bpm)', color='b')
    ax1.plot(heart_rate_df['Time'], heart_rate_df['Value'], color='b', label='Heart Rate')
    ax1.tick_params(axis='y', labelcolor='b')
    
    # Create a second y-axis for total intensity
    ax2 = ax1.twinx()
    ax2.set_ylabel('Total Intensity', color='g')
    ax2.plot(hourly_intensity_df['ActivityHour'], hourly_intensity_df['TotalIntensity'], color='g', label='Total Intensity')
    ax2.tick_params(axis='y', labelcolor='g')
    
    # Adding a title
    fig.suptitle(f'Heart Rate and Total Exercise Intensity for User {user_id}', fontsize=14)
    
    # Show the plot
    plt.tight_layout()
    plt.show()

    # Return the figure
    return fig

if __name__ == '__main__':
    df = load_data("daily_activity.csv")    

    # Generate unique users for 'TotalDistance'
    unique_users_distance = get_unique_users(df, column_name='TotalDistance')

    # Pass it to the function
    plot_distance_distribution(unique_users_distance)
    plot_workout(df)

    df['Id'] = df['Id'].astype(str)
    linear_regression_model = smf.ols('Calories ~ TotalSteps + C(Id)', data=df).fit()
    print(linear_regression_model.summary())

    user_id_test = df['Id'].iloc[0]  
    calories_burned_per_day(df, user_id=user_id_test, start_date="2016-03-01", end_date="2016-03-30")  

    plot_LRM(df, user_id=user_id_test)  
    
    user_classes = classify_user(df)
    print(user_classes)


    connection = sql.connect("fitbit_database.db")
    verify_total_steps(df, connection)
    df_sleep_duration = compute_sleep_duration(connection)
    df_sleep_activity, regression_model = analyze_sleep_vs_activity(connection)
    model = analyze_sleep_vs_sedentary(connection)
    plot_activity_by_time_blocks_from_db(connection)
    plot_heart_rate_and_intensity_by_id(connection, 1503960366)
    connection.close()
